# Домашна работа 1

Решенията на задачите се предават по e-mail на следните адреси:

* Група 1 - KN13.14.1.1@gmail.com
* Група 2 - kn201317@gmail.com
* Група 3 - lachezarstoev93@gmail.com | ts.kandilarova@gmail.com
* Група 4 - kn4_1314@abv.bg

Срок за предаване: 26.03.2014 - 2.04.2014

Решението на всяка задача трябва да бъде под формата на файлове с окончание
*.cpp* и *.h* (не целите проекти, ако използвате Visual Studio). Файловете се
изпращат като attachment-и в mail-a. Освен решения на задачите самият mail
трябва да съдържа име и факултен номер. Успех!


# Задача 1

Ще реализираме няколко класа, с които почти ще сме си направили играта
**Money Stream**. Ето какво представялава самата игра:

Играта се играе от двама човека. Създава се масив `money stream`, от цели числа,
с дължина `n`, (`n` e четно) който се запълва със случайни стойности. Двамата
хвърлят зар кой ще започне първи.

Първият избира едно цяло число в интервала **[0, n - 1]**, което ще бъде индекс
от масива. Стойноста от клетката на масива е сумата която човекът получава. Тази
сума се прибавя към общатата му сума с пари. Двамата играчи се редуват в избора
на индекси докато не останат повече клетки.

Накрая печели този с по-голям капитал.

## Ето каква част от играта ще реализираме ние

### Клас `Player`

* Един играч има следните атрибути
  * `score` - баланс от точки за играча
  * `nickname` - псевдоним на играча с произволна дължина (динамична)

* и следните методи
  * `конструктор` - с единствен параметър - `nickname`-ът на играча
  * `copy-конструктор`
  * `operator=`
  * `деструктор`
  * `char* getNickname()` - връща `nickname`-а на играча
  * `double getScore()` - връща точките на играча
  * `char* getInfo()` - връща низ състоящ се от прякора на играча и точките му
  * `void addScore(double value)` - приема стойност и я добавя към баланса на
  играча

### Клас `MoneyStream`

* Всяка изиграна игра се характеризира със следните атрибути
  * `stream`/`arr` - масив със случайни неотрицателни числа(по ваш избор)
  * `size` - големина на масива

* и следните методи
  * `конструктор` - с единствен параметър - големината на масива
  * `copy-конструктор`
  * `operator=`
  * `деструктор`
  * `int getSize()` - връща големината на зададения масив
  * `double getValue(int index)` - получава индекс и връща стойността от
  съответната клетка; ако съответната позиция от масива е била достъпвана, връща
  `-1`
  * `bool isAvailable(int index)` - получава индекс и връща лъжа, ако клетката
  е била достъпвана с `getValue` - иначе, истина
  * `bool hasAvailable()` - не приема аргументи; връща истина, ако има
  недостъпвани клетки(позиции), иначе - лъжа

## Задача 2 - Бонус

В тази задача ще напишем няколко класа свързани с играта **Minesweeper**.

### Клас `Cell`

Представя едно квадратче(клетка) от цялото поле по следния начин.

* Атрибути
  * `value` - цяло число определящо числото в клетката(0, ако е празна, -1, ако
  съдържа мина, 1-8 иначе)
  * `status` - от тип `CELL_STATUS`(enum), с възможни стойности - `OPEN`,
  `CLOSED`, `FLAGGED`

* Методи
  * `конструктор` - приемащ един аргумент - `value`-то на клетката; след
  създаване на клетката, статусът и трябва да е `CLOSED`
  * `CELL_STATUS status()` - връща статуса на клетката
  * `open()` - променя статуса на клетката на `OPEN` само ако е бил `CLOSED`
  * `flag()` - променя статуса на клетката на `FLAGGED` само ако е бил `CLOSED`
  * `unflag()` - променя статуса на клетката на `CLOSED` само ако е бил
  `FLAGGED`

### Клас `Field`

Представя цялата дъска(полето).

* Атрибути
  * `width` - колко клетки е широко полето
  * `height` - колко клетки е високо полето
  * `cells` - масив от `width` x `height` клетки(`Cell`s)

* Методи
  * `конструктор` - приема широчината и височината на полето
  * `copy-конструктор`
  * `operator=`
  * `деструктор`
  * `openCell(int x, int y)` - отваря клетката на позиция **[x][y]** само ако
  е затворена и се извиква отново за всички съседни клетки рекурсивно, докато не
  стигне до клетка с мина(пуснете си един **Minesweeper** ще видите как ви
  разкрива много полета като цъкнете на празно квадратче)
  * `flagCell(int x, int y)` - слага флагче на клетката само ако е била
  затворена
  * `unflagCell(int x, int y)` - маха флагчето от клетката само ако е имала
  такова
  * `isSolved` - връша истина, ако всички мини са флагнати или затворени, а
  останалите клетки са отворени, иначе лъжа
