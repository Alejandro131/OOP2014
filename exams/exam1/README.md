# Контролно  1 - 13.04.2014 г.

## Вариант 1

### Задача  1

Напишете клас `Pixel`, който моделира екранен пиксел. Нека в класа има три целочислени член-данни, които представят компонентите на цвета на пиксела. Една член-данна отговаря на един от основните цветове – *червен(red)*, *зелен(green)* и *син(blue)*. За класа да се реализират:

* подходящи конструктори
* подходящи `set` и `get` методи за член-данните на класа
* член-функция `print`, която отпечатва на екрана информацията за пиксел по следния начин: `[<red>, <green>, <blue>]`
* член-функция `getValue()`, която връща стойността на пиксел, която се изчислява по следната формула: `255 * 255 * <red> + 255 * <green> + <blue>`
* да се предефинират операторите за сравнение(`>`, `<`, `==`, `!=`) за пиксел, като се сравняват техните стойности
 
Всяка една от компонентите на пиксела е число в интервала **[0, 255]**

Напишете клас `ColorLine`, който моделира цветна линия. Нека в класа да има динамичен масив от пиксели. За класа да се реализират:

* канонично представяне
* да се дефинира конструктор, който приема брой пиксели, които ще съдържа цветната линия
* подходящи `set` и `get` методи
* функция `print()`, която отпечатва на екрана информацията за цветната линия в следния вид: `[<пиксел1>, <пискел2>, ..., <пикселN>]`
* функция, която сортира масива от пиксели в низходящ ред
* оператор `[]`, който дава достъп до пиксела на даден индекс

### Задача 2

Да се напише клас `SparseArray`, който моделира *разреден* масив от цели числа. Както и при обикновените масиви на всеки индекс в разредения масив съответства едно число. Индексите, които са запълнени не е задължително да са последователни, т.е. в масива може да има елементи само на позиции: 2, 8, 77, 5555, а на останалите позиции няма елементи. Използвайки структурата:

```c++
struct Item
{
    int index;
    int value;
};
```

реализирайте по подходящ начин описания вече масив. Нека за класа да се реализират следните функции:

* `bool addItem(int index, int value)`, която добавя в масива елемент със стойност `value` на позиция `index`. Ако добавянето е успешно функцията да връща `true`, а ако такъв индекс вече съществува да върне `false`.
* `int getValue(int index)`, която връща елемента, съответстващ на даден индекс. Ако индексът не съществува да върне `index`.
* `bool removeItem(int index, int& value)`, която премахва елемента от масива на място `index`. Ако има такъв индекс, стойността му да се запише в параметъра `value` и функцията да връща `true`. Иначе да не се правят промени в масива, в параметъра `value` да се запише `index` и функцията да връща `false`.

## Вариант  2

### Задача  1

Напишете клас `Pixel`, който моделира екранен пиксел. Нека в класа има четири целочислени член-данни, които представят компонентите на цвета на пиксела. Една член-данна отговаря на един от основните цветове – *светлосиньо(cyan)*, *пурпурно(magenda)*, *жълто(yellow)*, *черно(black)*. За класа да се реализират:

* подходящи конструктори
* подходящи `set` и `get` методи за член-данните на класа
* функция `print`, която отпечатва на екрана информацията за пиксел по следния начин: `[<cyan>, <magenda>, <yellow>, <black>]`
* функция `getValue()`, която връща стойността на пиксел, която се изчислява по следната формула: `128 * <cyan> + 64 * <magenda> + 32 * <yellow> +16 * <black>`
* да се предефинират операторите за сравнение(`>`, `<`, `==`, `!=`) за пиксел, като се сравняват техните стойности

Всяка една от компонентите на пиксела е число в интервала **[0, 255]**

Напишете клас `ColorLine`, който моделира цветна линия. Нека в класа да има динамичен масив от пиксели. За класа да се реализират:

* канонично представяне
* да се дефинира конструктор, който приема брой пиксели, които ще съдържа цветната линия
* подходящи `set` и `get` методи
* функция `print()`, която отпечатва на екрана информацията за цветната линия в следния вид: `[<пиксел1>, <пискел2>, ..., <пикселN>]`
* функция, която сортира масива от пиксели във възходящ ред
* оператор `[]`, който дава достъп до пиксела на даден индекс

### Задача  2

Да се напише клас `SparseArray`, който моделира *разреден* масив от целочислени елементи. Както и при обикновените масиви на всеки индекс съответства едно число. Индексите, които са запълнени не е задължително да са последователни, т.е. в масива може да има елементи само на позиции: 2, 7, 55, 1005, а на останалите позиции няма елементи. Използвайки структурата:

```c++
struct Item
{
    int index;
    int value;
};
```

реализирайте по подходящ начин описания вече масив. Нека за класа да се реализират следните функции:

* `bool addItem(int index, int value)`, която добавя в масива елемент със стойност `value` на позиция `index`. Ако добавянето е успешно функцията да връща `true`, а ако такъв индекс вече съществува да върне `false`.
* `int getValue(int index)`, която връща елемента, съответстващ на даден индекс. Ако индексът не съществува да върне 0.
* `bool removeItem(int index, int& value)`, която премахва елемента от масива на място `index`. Ако има такъв индекс, стойността му да се запише в параметъра `value` и функцията да връща `true`. Иначе да не се правят промени в масива, в параметъра `value` да се запише 0 и функцията да връща `false`.
